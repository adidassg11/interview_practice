4.9

As exercises in program verifications, precisely specify the input/output behavior of each of the following program fragments and show that the code meets it specification. The first program implements the vector addition a=b+c

i = 0
while i<n
        a[i] = b[i] + c[i]
        i = i+1

(this code and the next two fragments expand the 'for i = [0,n)' loop to a while loop with an increment at the end) The next fragment computes the max value in the array x.

max = x[0]
i = 1
while i < n do
    if x[1] > max
        max = x[i]
    i = i+1

This sequential search program returns the position of the first occurence of t in the array x[0..n-1]

i = 0
while i<n && x[i] != t
    i = i+1
if i>=n
    p = -1
else
    p = i

This program computes the nth power of x in time proportional to the log of n. This recursive program is straightforward to code and verify; the iterative version is subtle, and is left as an additional problem.

function exp(x, n)
        pre n>=0
        post result = x^n
    if n = 0
        return 1
    else if even(n)
        return square(exp(x, n/2))
    else
        return x*exp(x, n-1)4.9

As exercises in program verifications, precisely specify the input/output behavior of each of the following program fragments and show that the code meets it specification. The first program implements the vector addition a=b+c

i = 0
while i<n
        a[i] = b[i] + c[i]
        i = i+1

(this code and the next two fragments expand the 'for i = [0,n)' loop to a while loop with an increment at the end) The next fragment computes the max value in the array x.

max = x[0]
i = 1
while i < n do
    if x[1] > max
        max = x[i]
    i = i+1

This sequential search program returns the position of the first occurence of t in the array x[0..n-1]

i = 0
while i<n && x[i] != t
    i = i+1
if i>=n
    p = -1
else
    p = i

This program computes the nth power of x in time proportional to the log of n. This recursive program is straightforward to code and verify; the iterative version is subtle, and is left as an additional problem.

function exp(x, n)
        pre n>=0
        post result = x^n
    if n = 0
        return 1
    else if even(n)
        return square(exp(x, n/2))
    else
        return x*exp(x, n-1)4.9

As exercises in program verifications, precisely specify the input/output behavior of each of the following program fragments and show that the code meets it specification. The first program implements the vector addition a=b+c

i = 0
while i<n
        a[i] = b[i] + c[i]
        i = i+1

(this code and the next two fragments expand the 'for i = [0,n)' loop to a while loop with an increment at the end) The next fragment computes the max value in the array x.

max = x[0]
i = 1
while i < n do
    if x[1] > max
        max = x[i]
    i = i+1

This sequential search program returns the position of the first occurence of t in the array x[0..n-1]

i = 0
while i<n && x[i] != t
    i = i+1
if i>=n
    p = -1
else
    p = i

This program computes the nth power of x in time proportional to the log of n. This recursive program is straightforward to code and verify; the iterative version is subtle, and is left as an additional problem.

function exp(x, n)
        pre n>=0
        post result = x^n
    if n = 0
        return 1
    else if even(n)
        return square(exp(x, n/2))
    else
        return x*exp(x, n-1)4.9

As exercises in program verifications, precisely specify the input/output behavior of each of the following program fragments and show that the code meets it specification. The first program implements the vector addition a=b+c

i = 0
while i<n
        a[i] = b[i] + c[i]
        i = i+1

(this code and the next two fragments expand the 'for i = [0,n)' loop to a while loop with an increment at the end) The next fragment computes the max value in the array x.

max = x[0]
i = 1
while i < n do
    if x[1] > max
        max = x[i]
    i = i+1

This sequential search program returns the position of the first occurence of t in the array x[0..n-1]

i = 0
while i<n && x[i] != t
    i = i+1
if i>=n
    p = -1
else
    p = i

This program computes the nth power of x in time proportional to the log of n. This recursive program is straightforward to code and verify; the iterative version is subtle, and is left as an additional problem.

function exp(x, n)
        pre n>=0
        post result = x^n
    if n = 0
        return 1
    else if even(n)
        return square(exp(x, n/2))
    else
        return x*exp(x, n-1)
